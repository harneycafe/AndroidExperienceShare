## Flutter渲染
页面中的各界面元素（Widget）以树的形式组织，即控件树。Flutter通过控件树中的每个控件创建不同类型的渲染对象，组成渲染对象树。渲染对象树在Flutter的展示过程分为四个阶段：布局、绘制、合成、渲染。

### 布局
Flutter采用后序遍历来遍历渲染对象树，父Widget的布局需要依赖子Widget的布局结果，从而决定渲染对象树中各渲染对象在屏幕上的位置和尺寸。

![image](http://note.youdao.com/yws/res/816/WEBRESOURCE97729b17b0470df49dc967c91c705691)
如上图，渲染树中的每个子节点都会接收父节点的布局约束参数，决定自己的大小，然后父对象按照控件逻辑决定各个子节点的位置，完成布局过程。

为了防止因子节点发生变化导致整个控件树重新布局，Flutter加入了一个机制->布局边界，当边界内的任何对象发生重新布局时，不会影响边界外的对象，反之亦然。

如下图：
![image](http://note.youdao.com/yws/res/849/WEBRESOURCE42c00d987b5a92f0163ac668c4c89818)
可见，布局边界的实现就是在某一个父子节点连接线上作标记，可以把作标记的连接线的子节点以下当作一颗新树，其中的Widget变化只会重新渲染新树中的渲染对象。

### 绘制

布局阶段完成，渲染对象树中的每个节点都有了自己的尺寸和在屏幕中的位置，接下来就开始绘制了。

绘制也是有顺序的，在说绘制顺序之前，先来了解一个图层的概念：通俗地讲，图层就像是含有文字或图形等元素的胶片，一张张按顺序叠放在一起，组合起来形成页面的最终效果。图层可以将页面上的元素精确定位。打个比方说，在一张张透明的玻璃纸上作画，透过上面的玻璃纸可以看见下面纸上的内容，但是无论在上一层上如何涂画都不会影响到下面的玻璃纸，上面一层会遮挡住下面的图像。最后将玻璃纸叠加起来，通过移动各层玻璃纸的相对位置或者添加更多的玻璃纸即可改变最后的合成效果。


在Flutter 中会把所有的渲染对象绘制到不同的图层上。绘制过程按前序遍历，总是先绘制自身，再绘制子节点。节点1在绘制完自身后，会再绘制节点2，然后绘制它的子节点3、4和5，最后再绘制节点6。

如下图：
![image](http://note.youdao.com/yws/res/876/WEBRESOURCE909a5e3e32cd9fe076e8118a00469639)

一个颜色代表一个图层，可以看到，由于一些其他原因（比如视图手动合并）导致2的子节点5与它的兄弟节点6处于了同一图层，这样会导致节点2需要重绘的时候，与其无关的节点6也会被重绘，带来性能损耗。

为了解决这个性能损耗问题，Flutter提出了与布局边界对应的机制->重绘边界。在重绘边界内，Flutter会强制切换新的图层，这样就可以避免边界内外的互相影响，避免无关内容置于同一图层引起不必要的重绘。
![image](http://note.youdao.com/yws/res/923/WEBRESOURCE85eda83c8c6c4498981d4f8092022ec2)

重绘边界的一个典型场景是 Scrollview。ScrollView滚动的时候需要刷新视图内容，从而触发内容重绘。而当滚动内容重绘时，一般情况下其他内容是不需要重绘的，这时候重绘边界就派上用场了。

### 合成
终端设备的页面越来越复杂，因此Flutter的渲染树图层通常很多，直接交付给渲染引擎进行多图层的渲染，可能会出现大量渲染内容重复绘制，所以还需要先进行一次图层合成，即将所有的图层根据大小、层级、透明度等规则计算出最终显示效果，将相同的图层归类合并，简化渲染树，提高渲染效率。

### 渲染

合并完成后，Flutter会将几何图层数据交由Skia引擎加工成二维图像数据，最终交由GPU进行渲染。GPU完成渲染后将结果放入帧缓冲区，随后视频控制器根据垂直同步信号(VSync)以每秒60次的速度，从帧缓冲区读取帧数据交由显示器完成图像显示。
